<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[四元数 Quaternions]]></title>
    <url>%2F2019%2F04%2F29%2FQuaternions%2F</url>
    <content type="text"><![CDATA[1. 数学定义&emsp;&emsp;在进行四元数对旋转的作用探讨前，我们先看一下四元数的定义，并不管三七二十一扔出一堆公式以供后续使用。首先四元数是一种超复数，与简单复数仅包含一个虚部$i$，四元数包含三个虚部$i,j,k$和一个实部，这里定义四元数入下： $\hat{\textbf{q}}=(\textbf{q}_v, q_w)=iq_x+jq_y+kq_z+q_w \\ \textbf{q}_v=iq_x+jq_y+kq_z=(q_x,q_y,q_z)$ $i^2=j^2=k^2=-1, jk=-kj=i, ki=-ik=j,ij=-ji=k$ &emsp;&emsp;于是可以有如下的运算：Addition:&emsp;&emsp;&emsp; $\hat{\textbf{q}}+\hat{\textbf{r}}=(\textbf{q}_v, q_w)+(\textbf{r}_v, r_w) = (\textbf{q}_v+\textbf{r}_v,q_w+r_w)$ Multiplication:&emsp;$\hat{\textbf{q}}\hat{\textbf{r}}=(iq_x+jq_y+kq_z+q_w)(ir_x+jr_y+kr_z+r_w) =(\textbf{q}_v\times\textbf{r}_v+r_w\textbf{q}_v+q_w\textbf{r}_v, q_wr_w-\textbf{q}_v\cdot\textbf{r}_v)$ Conjugate:&emsp;&emsp;&emsp;$\hat{\textbf{q}}^*=(-\textbf{q}_v, q_w)$ Norm: &emsp;&emsp;&emsp;&emsp; $n(\hat{\textbf{q}})=\sqrt{\hat{\textbf{q}}\hat{\textbf{q}}^*}=\sqrt{\hat{\textbf{q}}^*\hat{\textbf{q}}}=\sqrt{\textbf{q}_v\cdot\textbf{q}_v+q_w^2}=\sqrt{q_x^2+q_y^2+q_z^2+q_w^2}$ Identity: &emsp;&emsp;&emsp;&emsp;$\hat{\textbf{i}}=(\textbf{0}, 1)$ Inverse:&emsp;&emsp;&emsp;&emsp;$\hat{\textbf{q}}^{-1}=\frac{1}{n(\hat{\textbf{q}})^2}\hat{\textbf{q}}^*$ &emsp;&emsp;然后我们可以定义单位向量为： $\hat{\textbf{q}}=(sin\phi\textbf{u}_q,cos\phi)=sin\phi\textbf{u}_q+cos\phi$ 其中$||\textbf{u}_q||=1$，可以验证$n(\hat{\textbf{q}})=1$，于是根据该形式我们可以将其改写为如下形式： $\hat{\textbf{q}}=sin\phi\textbf{u}_q+cos\phi=e^{\phi\textbf{u}_q}$ 于是可以扩展出如下定义：Logarithm:&emsp;&emsp;&emsp;$log(\hat{\textbf{q}})=\phi\textbf{u}_q$Power:&emsp;&emsp;&emsp;&emsp;&emsp;$\hat{\textbf{q}}^t=e^{\phi t\textbf{u}_q}=sin(\phi t)\textbf{u}_q + cos(\phi t)$ 2. 旋转&emsp;&emsp;现在我们有了四元数的定义，考虑有一个单位四元数$\hat{\textbf{q}}=(sin\phi \textbf{u}_q, cos\phi)$，和一个希望进行旋转的坐标$\textbf{p}=(p_x\ p_y\ p_z\ p_w)^T$，并将其装载为四元数$\hat{\textbf{p}}$，于是可以发现如下的公式： $\hat{\textbf{q}}\hat{\textbf{p}}\hat{\textbf{q}}^{-1}$ 那么这个公式做了什么事呢，先将绕轴旋转的图拿出来如下： 首先可以发现如下的结果： $\hat{\textbf{q}}^{-1}=\hat{\textbf{q}}^*=(-sin\phi \textbf{u}_q, cos\phi)$ $\textbf{u}\times\textbf{p}=\textbf{y}$ $\textbf{y}\times\textbf{u}=\textbf{x}$ $\textbf{p}\cdot\textbf{u}=||\textbf{u'}||$ 接下来即可以尝试将上述公式展开： $$\require{enclose} \begin{align*} \hat{\textbf{q}}\hat{\textbf{p}}\hat{\textbf{q}}^{-1} &= (sin\phi \textbf{u}_q, cos\phi)(\textbf{p}_v, p_w)(-sin\phi \textbf{u}_q, cos\phi) \\ &= (sin\phi \textbf{u}_q\times\textbf{p}_v + p_wsin\phi \textbf{u}_q+cos\phi\textbf{p}_v, p_wcos\phi-sin\phi(\textbf{u}_q\cdot\textbf{p}_v))(-sin\phi \textbf{u}_q, cos\phi) \\ &=(sin\phi \textbf{y} + p_wsin\phi \textbf{u}_q+cos\phi\textbf{p}_v, p_wcos\phi-sin\phi||\textbf{u'}||))(-sin\phi \textbf{u}_q, cos\phi) \\ &= ((-sin^2\phi\textbf{y}\times\textbf{u}_q - \enclose{horizontalstrike}{p_wsin^2\phi\textbf{u}_q\times\textbf{u}_q} - sin\phi cos\phi\textbf{p}_v\times\textbf{u}_q) \\ &\ \ \ \ + (sin\phi cos\phi \textbf{y} + \enclose{horizontalstrike}{p_wsin\phi cos\phi\textbf{u}_q} + cos^2\textbf{p}_v) \\ &\ \ \ \ +(-\enclose{horizontalstrike}{p_wsin\phi cos\phi\textbf{u}_q}+sin^2\phi||\textbf{u'}||\textbf{u}_q), \\ &\ \ \ \ p_wcos^2\phi-\enclose{horizontalstrike}{sin\phi cos\phi||\textbf{u'}||} - (-\enclose{horizontalstrike}{sin^2\phi(\textbf{y}\cdot\textbf{u}_q)}-p_wsin^2\phi(\textbf{u}_q\cdot\textbf{u}_q)-\enclose{horizontalstrike}{sin\phi cos\phi(\textbf{p}_v\cdot\textbf{u}_q)}))\\ &=(-sin^2\textbf{x}+2sin\phi cos\phi \textbf{y} + cos^2\phi \textbf{p}_v + sin^2\phi\textbf{u'},p_w) \\ &=(-sin^2\textbf{x}+2sin\phi cos\phi \textbf{y} + cos^2\phi (\textbf{p}_v - \textbf{u'}) + \textbf{u'},p_w) \\ &=((cos^2\phi-sin^2\phi)\textbf{x}+2sin\phi cos\phi \textbf{y} + \textbf{u'},p_w) \\ &=(cos(2\phi)\textbf{x}+sin(2\phi)\textbf{y}+\textbf{u'},p_w) \end{align*} $$&emsp;&emsp;显然，该式实部未改变$p_w$的值，而虚部刚好使$(p_x, p_y, p_z)^T$按照单位轴$\textbf{u}_q$旋转了$2\phi$，如下图所示：]]></content>
      <categories>
        <category>数学 Math</category>
      </categories>
      <tags>
        <tag>旋转</tag>
        <tag>矩阵变换</tag>
        <tag>Rotation</tag>
        <tag>Matrix Transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轴向角 Axis Rotation]]></title>
    <url>%2F2019%2F04%2F28%2FAxis-Rotation%2F</url>
    <content type="text"><![CDATA[1. 简单的想法&emsp;&emsp;一般来说我们可以很容易写出绕坐标轴$x,y,z$旋转任意角度$\theta$的旋转矩阵，这里分别用$\textbf{R}_x(\theta), \textbf{R}_y(\theta), \textbf{R}_z(\theta)$来表示。但更多时候，我们希望给出任意轴$\textbf{r}$和任意角度$\alpha$的旋转矩阵$\textbf{X}$。一个简单的想法即将$\textbf{s}$构成的局部坐标系$Orst$变换到$Oxyz$上，然后应用相应的旋转，最后反变换回去，如下图所示： &emsp;&emsp;首先我们计算$\textbf{M}$，按照Real-Time Rendering (4th Edition)中，一个比较稳定的方法即将绝对值最小值置零，然后交换剩下的值并将前一个值取负，可以验证该方法生成的向量与$\textbf{r}$垂直，只是需要进一步归一化，于是可以有： $\overline{\textbf{s}}=\left\{\begin{array}{cccc} (0,-r_z,r_y) & if\ |r_x|\le|r_y|\ and\ |r_x|\le|r_z| \\ (-r_z,0,r_x) & if\ |r_y|\le|r_x|\ and\ |r_y|\le|r_z| \\ (-r_y,r_x,0) & if\ |r_z|\le|r_x|\ and\ |r_z|\le|r_y| \end{array}\right. \\ \textbf{s}=normalize(\overline{\textbf{s}}) \\ \textbf{t} = \textbf{r}\times \textbf{s}$ &emsp;&emsp;对应的即可以得到$\textbf{M}$: $\textbf{M}=\left[\begin{array}{cccc} \textbf{r}^T \\ \textbf{s}^T \\ \textbf{r}^T \end{array}\right]$ &emsp;&emsp;按照上述的坐标轴转换，最终的旋转矩阵即可以表示为： $\textbf{M}=\textbf{M}^T\textbf{R}_x(\alpha)\textbf{M}$ 2. glm::rotate()&emsp;&emsp;然而很容易发现该方案效率较低，需要多个计算，在glm::rotate()中，使用了Graphics Gems (1st Edition)中提到的另一种方法。该方法更直观地在旋转轴上进行操作，如下图所示。 &emsp;&emsp;首先我们有归一化的旋转轴$\textbf{r}$和任意需要旋转的点，这里用向量$\textbf{p}$表示，以及旋转角度$\phi$后的位置$\textbf{p’}$。如上图所示，我们将$\textbf{p}$投影到$\textbf{r}$上得到相应的投影向量： $\textbf{r'}=||\textbf{p}||cos\theta\ \textbf{r} = (\textbf{p}\cdot\textbf{r})\textbf{r}$ &emsp;&emsp;将$\textbf{x}=\textbf{p}-\textbf{r'}$作为旋转起始轴构建局部二维坐标系$\textbf{x}\textbf{y}$，那么在该局部坐标系下的旋转和最终的旋转结果即可表示为： $\textbf{t'}=cos\phi\ \textbf{x}+sin\phi\ \textbf{y} \\ \textbf{p'}=\textbf{r'}+\textbf{t'}=\textbf{r'}+cos\phi\ \textbf{x}+sin\phi\ \textbf{y}$ 上述已知$\textbf{r'}$，于是我们现在开始分别计算$\textbf{x}$，$\textbf{y}$： $\textbf{x}=\textbf{p}-\textbf{r'} =\textbf{p}- (\textbf{p}\cdot\textbf{r})\textbf{r} \\ \textbf{y} = \textbf{r}\times\textbf{p}$ 可以验证$||\textbf{x}||=||\textbf{p}||sin\theta=||\textbf{y}||$，然后将$\textbf{p'}$的计算式改写为： $\textbf{p'} = (\textbf{p}\cdot\textbf{r})\textbf{r}+cos\phi\ (\textbf{p}- (\textbf{p}\cdot\textbf{r})\textbf{r})+sin\phi\ \textbf{r}\times\textbf{p} \\ = cos\phi \textbf{p}+ (1-cos\phi)(\textbf{p}\cdot\textbf{r})\textbf{r}+sin\phi\ \textbf{r}\times\textbf{p} $ &emsp;&emsp;接下来想办法将$\textbf{p}$提出来，剩下的算式组成的矩阵即是我们需要的旋转矩阵。在Graphics Gems (1st Edition)给出了如下的几个公式： $\textbf{p}=\textbf{Ip} \\ (\textbf{p}\cdot\textbf{r})\textbf{r} = \textbf{r}(\textbf{r}^T\textbf{p})=\left[\begin{array}{cccc} r_x^2 & r_xr_y & r_xr_z \\ r_xr_y & r_y^2 & r_yr_z \\ r_xr_z & r_yr_z & r_z^2\end{array}\right]\textbf{p}\\ \textbf{r}\times\textbf{p}=\left[\begin{array}{cccc} r_y p_z - r_z p_y \\ r_z p_x - r_x p_z \\ r_x p_y - r_y p_x \end{array}\right] = \left[\begin{array}{cccc} 0 & -r_z & r_y \\ r_z & 0 & -r_x \\ -r_y & r_x & 0 \end{array}\right]\textbf{p}$ 于是有： $\textbf{p'} = (cos\phi \textbf{I}+ (1-cos\phi)\left[\begin{array}{cccc} r_x^2 & r_xr_y & r_xr_z \\ r_xr_y & r_y^2 & r_yr_z \\ r_xr_z & r_yr_z & r_z^2\end{array}\right]+sin\phi\left[\begin{array}{cccc} 0 & -r_z & r_y \\ r_z & 0 & -r_x \\ -r_y & r_x & 0 \end{array}\right]) \textbf{p}$ &emsp;&emsp;综上所述我们可以将该旋转矩阵表示为： $\textbf{M}=\left[\begin{array}{cccc} cos\phi+(1-cos\phi)r_x^2 & (1-cos\phi)r_xr_y-r_zsin\phi & (1-cos\phi)r_xr_z+r_ysin\phi \\ (1-cos\phi)r_xr_y+r_zsin\phi & cos\phi+(1-cos\phi)r_y^2 & (1-cos\phi)r_yr_z-r_xsin\phi \\ (1-cos\phi)r_xr_z-r_ysin\phi & (1-cos\phi)r_yr_z+r_xsin\phi & cos\phi+(1-cos\phi)r_z^2 \end{array}\right]$ 参考文献Real-Time Rendering (4th Edition)Graphics Gems (1st Edition)]]></content>
      <categories>
        <category>数学 Math</category>
      </categories>
      <tags>
        <tag>旋转</tag>
        <tag>矩阵变换</tag>
        <tag>Rotation</tag>
        <tag>Matrix Transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉角 Euler Angle]]></title>
    <url>%2F2019%2F04%2F27%2FEuler-Transform%2F</url>
    <content type="text"><![CDATA[1. 定义&emsp;&emsp;欧拉角通过基于三个基础坐标轴的旋转角度生成一个矩阵，用于对坐标或坐标系的旋转。首先我们需要规定一个旋转顺序，这里按照Real-Time Rendering (4th Edition)中的规定，按照如下顺序进行旋转： $\textbf{E}(h,p,r)=\textbf{R}_z(r)\textbf{R}_x(p)\textbf{R}_y(h)$ &emsp;&emsp;一般定义:&emsp;&emsp;&emsp;&emsp;Yaw（偏航）：y&emsp;&emsp;&emsp;&emsp;Pitch（俯仰）：x&emsp;&emsp;&emsp;&emsp;Roll（翻滚）： z &emsp;&emsp;这里即可以看出其中一个问题，即旋转顺序对结果会产生影响，因此在不同的系统中若要进行移植需要确定坐标系朝向，以及相应的欧拉角顺序。此外该方法可能出现万向锁（Gimbal Lock），说明该问题前，我们先把$\textbf{E}(h,p,r)$展开： $\textbf{E}(h,p,r)=\left[\begin{array}{cccc} c_z c_y - s_z s_x s_y & -s_z c_x & c_z s_y + s_z s_x c_y \\ s_z c_y + c_z s_x s_y & c_z c_x & s_z s_y - c_z s_x c_y \\ -c_x s_y & s_x & c_x c_y \end{array}\right] $ 这里当$c_x=0, s_x=\pm 1$时，上式可以转换为： $\textbf{E}(h,p,r)=\left[\begin{array}{cccc} c_z c_y \mp s_z s_y & 0 & c_z s_y \pm s_z s_x c_y \\ s_z c_y \pm c_z s_x s_y & 0 & s_z s_y \mp c_z s_x c_y \\ 0 & \pm 1 & 0 \end{array}\right] = \left[\begin{array}{cccc} cos(r\pm h) & 0 & sin(r\pm h) \\ sin(r\pm h) & 0 & -cos(r\pm h) \\ 0 & \pm1 & 0 \end{array}\right] $ 可以看出这种情况下$r$和$h$是绕着同一个轴同向或反向旋转。 2. 求解参数&emsp;&emsp;很容易发现，当我们有欧拉角时，计算相应的旋转矩阵会很容易。但当我们有旋转矩阵，希望得到欧拉角就很难直观地想到结果，假如我们得到如下的旋转矩阵： $\textbf{E}=\left[\begin{array}{cccc} e_{00} & e_{01} & e_{02} \\ e_{10} & e_{11} & e_{11} \\ e_{20} & e_{21} & e_{22} \end{array}\right] $&emsp;&emsp;根据上述推导，很容易有： $\frac{e_{01}}{e_{11}} = \frac{-s_z}{c_z}=-tan_z$ $\frac{e_{20}}{e_{22}} = \frac{-s_y}{c_y}=-tan_y$ $e_{21}=sin_x$&emsp;&emsp;于是可以得到： $h = atan2(-e_{20}, e_{22}) \\ p = arcsin(e_{21}) \\ r = atan2(-e_{01}, e_{11})$&emsp;&emsp;于是由于死锁的存在， 在死锁中或死锁附近时，上述结果可能有很多组解，就可能准确插值变得困难，比如对于起点A和重点B，每次插值选择一个近似解，在死锁附近时，这个解的取值范围可能很广（如死锁时可以有无数组r-h解），那么我们插出来的结果就可能产生抖动。 参考文献Real-Time Rendering (4th Edition)]]></content>
      <categories>
        <category>数学 Math</category>
      </categories>
      <tags>
        <tag>旋转</tag>
        <tag>矩阵变换</tag>
        <tag>Rotation</tag>
        <tag>Matrix Transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[法向量变换 Normal Transformation]]></title>
    <url>%2F2019%2F04%2F23%2FNormal-Transformation%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在绘制物体的过程中，我们常常需要对物体的形状、位置等进行变换，从而可以从物体空间变换到世界空间，进而变换到相机空间，这些过程我们都可以通过矩阵乘法进行实现。对于点本身的位置$\textbf{p}$，假设我们有变换$\textbf{M}$，那么变换后的点位置为： $\textbf{p'}=\textbf{Mp}$ &emsp;&emsp;对于切向量，由于其可以视为切平面上的一点，与模型中的点位置变换是一致的，于是可以对切向量$\textbf{t}$做相同的变换： $\textbf{t'}=\textbf{Mt}$&emsp;&emsp;但对于法向量来说，若我们直接应用相同的变换，在诸如放缩的操作后，可能出现如下的情况： &emsp;&emsp;令变换前的切向量和法向量分别为$\textbf{t}$和$\textbf{n}$，以及变换后的结果分别为$\textbf{t’}$和$\textbf{n’}$，那么希望有： $\textbf{n'}^T\textbf{t'}=\textbf{n}^T\textbf{t}=\textbf{0}$&emsp;&emsp;已知$\textbf{t}$的变换为$\textbf{M}$，假设对$\textbf{n}$的变换为$\textbf{G}$，那么有： $\textbf{n'}^T\textbf{t'}=\textbf{(Gn)}^T\textbf{(Mt)}=\textbf{n}^T\textbf{G}^T \textbf{Mt}=\textbf{0}$&emsp;&emsp;于是可以预见的一个解为$\textbf{G}^T \textbf{M}=\textbf{I}$，可以得到： $\textbf{G}=(\textbf{M}^{-1})^T$&emsp;&emsp;但该方法要求$\textbf{M}$可逆，以及该变换不保证向量长度不变，因此可能需要归一化。另一种方法是计算法向量端点位置$\textbf{p}_1$、$\textbf{p}_2$，分别进行变换，再计算变换后的结果$\textbf{p’}_2-\textbf{p’}_1$。&emsp;&emsp;并且对于平移我们是不必在乎的，所以可以只关注左上角3*3的部分。若变换只包含旋转和平移，我们也可以直接应用原变换，并且不需要重新归一化。]]></content>
      <categories>
        <category>数学 Math</category>
      </categories>
      <tags>
        <tag>矩阵变换</tag>
        <tag>Matrix Transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lookAt() 函数]]></title>
    <url>%2F2019%2F04%2F23%2FlookAt-function%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在OpenGL中我们可以借助gluLookAt()或glm::lookAt()函数设置或者获取相应的视角转换矩阵，从而将片元从世界坐标系转换到相机坐标系。接下来我们以glm::lookAt()为例讲述这一过程具体是如何实现的。首先我们可以看一下glm::lookAt()的函数声明：123456template&lt;typename T, qualifier Q&gt;GLM_FUNC_QUALIFIER mat&lt;4, 4, T, Q&gt; lookAt( vec&lt;3, T, Q&gt; const &amp;eye, vec&lt;3, T, Q&gt; const&amp; center, vec&lt;3, T, Q&gt; const&amp; up); &emsp;&emsp;容易看出这是一个函数模板，接受三个三维向量，分别代表相机的位置eye、观察点center、朝上的方向up，并返回一个视角转换矩阵。在讲述原理前，我们先说明一下OpenGL中通常使用的坐标系。&emsp;&emsp;如下图所示，在OpenGL中，我们通常使用右手坐标系 $\textbf{O}xyz$ ，即$\textbf{z}=\textbf{x}\times \textbf{y}$，并且希望经过视角变换后相机看向$-\textbf{z}$方向，并且相机朝上方向为$\textbf{y}$，即下图所示的$\textbf{O}ruv$: &emsp;&emsp;接下来即可考虑如何根据三个输入参数eye、center、up获取上述转换矩阵。&emsp;&emsp;在上面的场景中，我们先根据三个输入参数计算世界坐标系下的三个相互正交的轴（需要说明的是输入参数up未必与视线垂直，因此需要校准）： $\textbf{v} = normalize(\textbf{center} - \textbf{eye}) \\ \textbf{r} = normalize(\textbf{up} )\times \textbf{v} \\ \textbf{u} = \textbf{v}\times \textbf{r}$ &emsp;&emsp;然后即是将eye平移到坐标系原点，令$\textbf{t}=-\textbf{eye}$，则有平移矩阵： $\textbf{R}=\left[\begin{array}{cccc} 1 & 0 & 0 & t_x \\ 0 & 1 & 0 & t_y \\ 0 & 0 & 1 & t_z \\ 0 & 0 & 0 & 1\end{array}\right]$ &emsp;&emsp;继续将三个轴变换到相应的位置即可，看到如下每一行分别与$\textbf{r}$点积j的结果刚好为$[-1,0,0]$，达到了我们希望将该坐标系变换到上述的位置。（前提是三个轴两两正交） $\textbf{R}=\left[\begin{array}{cccc} -r_x & -r_y & -r_z & 0 \\ u_x & u_y & u_z & 0 \\ -v_x & -v_y & -v_z & 0 \\ 0 & 0 & 0 & 1\end{array}\right]$ &emsp;&emsp;综上，转换矩阵为： $\textbf{M}=\textbf{RT} = \left[\begin{array}{cccc} -r_x & -r_y & -r_z & -\textbf{r}\cdot\textbf{t} \\ u_x & u_y & u_z & \textbf{u}\cdot\textbf{t} \\ -v_x & -v_y & -v_z & -\textbf{v}\cdot\textbf{t} \\ 0 & 0 & 0 & 1\end{array}\right]$ &emsp;&emsp;可以通过如下代码进行验证（此处默认右手系，在GLM中可以自主选择左右手系：123456789101112131415161718192021222324252627282930313233343536#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; glm::vec3 eye(1, 1, 1); glm::vec3 up(0, 1, 0); glm::vec3 center(0, 0, 0); glm::mat4x4 lookat = glm::lookAt(eye, center, up); for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; cout &lt;&lt; lookat[j][i] &lt;&lt; '\t'; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; glm::vec3 v = glm::normalize(center - eye); glm::vec3 r = glm::normalize(glm::cross(up, v)); glm::vec3 u = glm::normalize(glm::cross(v, r)); glm::vec3 t = -eye; t = glm::vec3(glm::dot(-r, t), glm::dot(u, t), glm::dot(-v, t)); cout &lt;&lt; -r[0] &lt;&lt; '\t' &lt;&lt; -r[1] &lt;&lt; '\t' &lt;&lt; -r[2] &lt;&lt; '\t' &lt;&lt; t[0] &lt;&lt; endl; cout &lt;&lt; u[0] &lt;&lt; '\t' &lt;&lt; u[1] &lt;&lt; '\t' &lt;&lt; u[2] &lt;&lt; '\t' &lt;&lt; t[1] &lt;&lt; endl; cout &lt;&lt; -v[0] &lt;&lt; '\t' &lt;&lt; -v[1] &lt;&lt; '\t' &lt;&lt; -v[2] &lt;&lt; '\t' &lt;&lt; t[2] &lt;&lt; endl; cout &lt;&lt; 0 &lt;&lt; '\t' &lt;&lt; 0 &lt;&lt; '\t' &lt;&lt; 0 &lt;&lt; '\t' &lt;&lt; 1 &lt;&lt; endl; return 0;&#125; 参考文献：Real Time Rendering (4th edition)]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>矩阵变换</tag>
        <tag>Matrix Transform</tag>
        <tag>OpenGL</tag>
        <tag>functions</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蒙特卡洛积分 Monte Carlo Integration]]></title>
    <url>%2F2019%2F04%2F09%2FMonte-Carlo-Integration%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;根据维基百科，蒙特卡洛积分法是基于随机数的数值积分方法，用于计算定积分。对于高维的积分该方法具有巨大优势，因为蒙特卡洛方法是基于随机采样的方法，而很多其他方法是基于grid的，即将空间分割为不同的grid，最终将每个grid中的计算结果汇总，在n维的情况下这些方法就是O(n)的空间复杂度，而蒙特卡洛仍为O(1)，但要达到相同的精度，所需要的采样数量是否一定优于grid的方法，我暂时还未得到证明。 1. 算法说明&emsp;&emsp; 那么接下来我们来看看蒙特卡洛积分描述了怎样一个过程。&emsp;&emsp; 以一维的定积分$\int_{a}^{b}f(x)dx$为例，我们去找一个分布，其概率密度为： $pdf(x)=\left\{ \begin{array}{cccc} p(x) & x\in (a, b) \\ 0 & else \end{array}\right.$ &emsp;&emsp; 那么在该分布上的$f(x)$的期望为： $E[f(x)]=\int_{a}^{b}f(x)p(x)dx$ &emsp;&emsp; 离散化后即可以有： $E[f(x)]\approx \frac{1}{n}\sum_{i=1}^{n}f(x_i)$ &emsp;&emsp; 其中$x_i$是按照$pdf(x)$采样出的某一样本。到现在可以看到我们距离目标积分，只差把$p(x)$消除掉。考虑定义函数$g(x)=\frac{f(x)}{p(x)}$，在该分布下$g(x)$的期望则是： $E[g(x)]=\int_{a}^{b}f(x)dx\approx \frac{1}{n}\sum_{i=1}^{n}\frac{f(x_i)}{p(x_i)}$ &emsp;&emsp; 综上所述，我们只要找到一个在该定义域上的分布，并且按照该分布采样多个样本$\{x_i\}^n$，最终将计算值求平均即得到该定积分的近似解： $\int_{a}^{b}f(x)dx\approx \frac{1}{n}\sum_{i=1}^{n}\frac{f(x_i)}{p(x_i)}$ 2. 例子&emsp;&emsp; 一个比较常见的蒙特卡洛方法即投点法，如下图的rejective方法（取自维基百科）：&emsp;&emsp; 那么怎么用上述推导来解释这个过程呢。我这里给了一个可能的解释，首先可以定义一个二维函数$f(x,y)$: $f(x,y)=\left\{ \begin{array}{cccc} 1& x^2+y^2 \le 1\\ 0 & else \end{array}\right.$&emsp;&emsp;那么红色部分的面积即为$\iint_{D}f(x,y)dxdy$，其中$D$为正方形区域。那么投点做了什么事呢——在正方形区域中均匀采样，故$pdf(x,y)=1$，所以可以得到： $\iint_{D}f(x,y)dxdy\approx \frac{1}{n}\sum_{i=1}^{n}\frac{f(x_i)}{pdf(x_i)} = \frac{1}{n}\sum_{i=1}^{n}f(x_i)$这个求和即为：若采样点落在圆中，则计数加一，否则reject。 3. 重要性采样&emsp;&emsp; 关于重要性采样的在蒙特卡洛积分中的作用，我们可以看如下这个半球面积分的例子： $\iint_{\Omega}cos\theta d\theta$&emsp;&emsp; 如果在半球面上进行均匀采样，蒙特卡洛方法如下： $\iint_{\Omega}cos\theta d\theta=\iint_{\Omega}\frac{cos\theta}{\frac{1}{2\pi}}\frac{1}{2\pi} d\theta\approx \frac{2\pi}{n}\sum_{i=1}^{n}cos\theta$&emsp;&emsp; 而如果进行Cosine Weight的采样，则有如下结果： $\iint_{\Omega}cos\theta d\theta=\iint_{\Omega}\frac{cos\theta}{\frac{cos\theta}{\pi}}\frac{cos\theta}{\pi} d\theta\approx \frac{\pi}{n}\sum_{i=1}^{n}1$&emsp;&emsp; 可以看到当我们的分布的概率密度刚好与$f(x)$差一个常数倍的话，我们甚至只需要采样一次。因此当分布于函数越相近时，我们所需要的采样数也就越少。]]></content>
      <categories>
        <category>数学 Math</category>
      </categories>
      <tags>
        <tag>sampling</tag>
        <tag>Monte Carlo</tag>
        <tag>采样</tag>
        <tag>蒙特卡洛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[球面采样 Spherical Sampling]]></title>
    <url>%2F2019%2F04%2F07%2FSpherical-Sampling%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文探索了几种不同的在球面或半球面上采样的方法。 1. 轴向均匀采样（Uniform Axis）&emsp;&emsp;最容易想到的采样方式即在三个互相垂直的坐标轴$x$,$y$,$z$上单独进行均匀采样，最后将采样到的坐标值正则化即可，不过需要注意的是该采样方式可能取到$(0,0,0)$这个坐标。伪代码如下：1234567do&#123; x = uniform(-1, 1); y = uniform(-1, 1); z = uniform(-1, 1);&#125;while((x,y,z) == (0,0,0));return normalize((x,y,z)); &emsp;&emsp;然而该方法最大的问题是其在球面上的采样非均匀，由于该方式实际上是将立方体中均匀分布的点映射到球面上，因此在立方体角点处会采样到更多的点，如下图所示： 2. 轴向正态采样 （Normal Axis）&emsp;&emsp;该方法与第一种方法类似，但不是均匀采样，而是在每个轴上独立进行正态采样，然后同样地映射到半球面上即可。伪代码如下：1234567do&#123; x = normal(-1, 1) y = normal(-1, 1) z = normal(-1, 1)&#125;while((x,y,z) == (0,0,0))return normalize((x,y,z)) &emsp;&emsp;从下图可以看出，该正态采样方式是球形t对称（spherical symmetric）的，其在球面上的映射也是均匀的。 3. Marsaglia采样&emsp;&emsp;该方法是一种基于变换的抽样方法，相较于方法1该方法保证了球面采样的均匀性，而与方法2比较该方法更快速，如下图所示：&emsp;&emsp;根据维基百科所述，Marsaglia算法可以以较快的速度一次性生成一对相互独立的符合标准正态分布的采样。但如下的方法，本人才疏学浅，并未发现其与正态分布的联系，仅对变换的均匀性做了简单证明。&emsp;&emsp;伪代码如下：12345678910do&#123; u = uniform(-1, 1); v = uniform(-1, 1); r2 = u^2 + v^2;&#125;while(r2 &gt; 1);x = 2 * u * sqrt(1 - r2);y = 2 * v * sqrt(1 - r2);z = 1 - 2 * r2;return (x, y, z); &emsp;&emsp;简单来说，该方法希望找到一个从圆盘$D$到球面$S$的均匀映射。因此首先在圆盘上通过rejective sampling方式进行均匀采样的到坐标$(u, v)$，然后魔幻现实主义地给出了如下映射： $x=2u\sqrt{(1-r^2)}$ $y=2v\sqrt{(1-r^2)}$ $z=1-2r^2$ &emsp;&emsp;令$t=(x,y,z)$为单位球面$S$上的某一点，令$f(t)$表示其概率密度，那么由于单位球面面积为$4\pi$，我们可以得到： $f(t)=\frac{1}{4\pi}$ &emsp;&emsp;而根据我们的目标，我们希望将$S$上的积分变换到$D$上，于是希望： $1=\iint_{S}f(t)dS=\iint_{uv}f(u,v)dudv$ &emsp;&emsp;更准确而言： $f(t)dS=f(u,v)dudv$ &emsp;&emsp;现在即需要对此进行证明，由于$u,v$在$D$上进行均匀采样，因此有$f(u,v)=\frac{1}{\pi}$。然后对$dS$进行变换： $dS=\sqrt{1+(\frac{\partial{z}}{\partial{x}})^2+(\frac{\partial{z}}{\partial{y}})^2}dxdy=\frac{1}{z}dxdy$ $dxdy=det(J)dudv=\left|\begin{array}{cccc} \frac{\partial{x}}{\partial{u}} & \frac{\partial{x}}{\partial{v}} \\ \frac{\partial{y}}{\partial{u}} & \frac{\partial{y}}{\partial{v}} \end{array}\right| dudv=4(1-2r^2)dudv=4zdudv$ &emsp;&emsp;即可得到$dS=4dudv$，综上即有： $f(t)dS=\frac{1}{4\pi}*4dudv=f(u,v)dudv$ 4. 半球面采样&emsp;&emsp;如果仅需要对半球面进行均匀采样，那么可以采用如下的变换方式： $z=rand(),\phi=rand()$ $r=\sqrt{1-z^2}$ $\Phi=2\pi\phi$ $x=rcos\Phi, y=rsin\Phi$&emsp;&emsp;同样地可以该出类似的证明: $f(z,\phi)=1$ $dS=\frac{1}{z}dxdy$ $det(J)=\left|\begin{array}{cccc} \frac{\partial{x}}{\partial{u}} & \frac{\partial{x}}{\partial{v}} \\ \frac{\partial{y}}{\partial{u}} & \frac{\partial{y}}{\partial{v}} \end{array}\right| = 4\pi z$ $f(t)dS=f(t,\phi)dzd\phi$&emsp;&emsp;基于该变换我们可以得到如下的半球面均匀采样： 5. Cos采样 （Cosine Weight Sampling）&emsp;&emsp;该方法生成的点云坐标距离圆盘$D$中心越近，其密度越高。其采样方式与半球面均匀采样有细微差别： $z=\sqrt{rand()},\phi=rand()$ $r=\sqrt{1-z^2}$ $\Phi=2\pi\phi$ $x=rcos\Phi, y=rsin\Phi$&emsp;&emsp;生成的点云如下： 6. 比较&emsp;&emsp;这里我比较了上述3种均匀采样的采样速度，其中实现语言使用的C++，随机数生使用的是标准库的的随机数生成器，得到了如下的结果： 采样数 1e4 1e5 1e6 Marsaglia 0.001s 0.011s 0.116s Normal-Axis 0.001s 0.029s 0.282s Hemi 0.001s 0.008s 0.078s &emsp;&emsp;就上述结果来看，全球面采样上，Marsaglia比正态轴向采样更快，虽然是基于rejective的方法。而半球面上的采样则比这两种方法都快速。 Referencehttp://corysimon.github.io/articles/uniformdistn-on-sphere/https://www.cnblogs.com/cofludy/p/5894270.html]]></content>
      <categories>
        <category>图形学 Computer Graphics</category>
      </categories>
      <tags>
        <tag>sampling</tag>
        <tag>采样</tag>
      </tags>
  </entry>
</search>
